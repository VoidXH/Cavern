using System;
using System.Numerics;
using System.Runtime.CompilerServices;

using Cavern.Filters;

namespace Cavern {
    /// <summary>
    /// An audio object in 3D space, in stereo, or both.
    /// </summary>
    public partial class Source {
        // ------------------------------------------------------------------
        // Audio clip settings
        // ------------------------------------------------------------------
        /// <summary>
        /// The audio clip to play.
        /// </summary>
        public Clip Clip;

        /// <summary>
        /// Continue playback of the source.
        /// </summary>
        public bool IsPlaying = true;

        /// <summary>
        /// Restart the source when finished.
        /// </summary>
        public bool Loop;

        /// <summary>
        /// Mute the source.
        /// </summary>
        public bool Mute;

        /// <summary>
        /// Only mix this channel to subwoofers.
        /// </summary>
        public bool LFE;

        /// <summary>
        /// The object position is relative to the screen and scales with screen size.
        /// </summary>
        /// <remarks>TODO: implement this</remarks>
        public bool screenLocked;

        // ------------------------------------------------------------------
        // 1D processing
        // ------------------------------------------------------------------
        /// <summary>
        /// Source playback volume (ratio to full volume).
        /// </summary>
        public float Volume = 1;

        /// <summary>
        /// Playback speed with no pitch correction.
        /// </summary>
        public float Pitch = 1;

        /// <summary>
        /// Balance between left and right channels.
        /// </summary>
        public float stereoPan;

        // ------------------------------------------------------------------
        // 3D processing
        // ------------------------------------------------------------------
        /// <summary>
        /// Balance between 1D and 3D mixing. 0 is 1D and 1 is 3D.
        /// </summary>
        public float SpatialBlend = 1;

        /// <summary>
        /// Audio source size relative to <see cref="Listener.EnvironmentSize"/>. 0 is a point, 1 is the entire room.
        /// </summary>
        public float Size;

        /// <summary>
        /// Doppler effect scale, 1 is real.
        /// </summary>
        public float DopplerLevel;

        /// <summary>
        /// Volume decreasing function by distance.
        /// </summary>
        public Rolloffs VolumeRolloff = Rolloffs.Logarithmic;

        /// <summary>
        /// Filter to be applied on the 3D mixed output.
        /// </summary>
        public Filter SpatialFilter;

        /// <summary>
        /// Simulates distance, not just direction when using virtualization.
        /// </summary>
        public bool DistanceSimulation;

        // ------------------------------------------------------------------
        // Variables
        // ------------------------------------------------------------------
        /// <summary>
        /// Object position in absolute space.
        /// </summary>
        public Vector3 Position;

        /// <summary>
        /// Clip playback position in samples.
        /// </summary>
        public int TimeSamples;

        // ------------------------------------------------------------------
        // Properties
        // ------------------------------------------------------------------
        /// <summary>
        /// Last collected samples from the clip or the last samples generated by overriding <see cref="GetSamples"/>.
        /// </summary>
        public MultichannelWaveform Rendered;

        /// <summary>
        /// Indicates that the source meets rendering requirements, and <see cref="GetSamples"/> won't fail.
        /// </summary>
        protected internal virtual bool Renderable => IsPlaying && Clip;

        // ------------------------------------------------------------------
        // Public functions
        // ------------------------------------------------------------------
        /// <summary>
        /// Implicit null check.
        /// </summary>
        public static implicit operator bool(Source source) => source != null;

        /// <summary>
        /// Start playback from the beginning of the <see cref="Clip"/> immediately.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Play() => Play(0);

        /// <summary>
        /// Start playback from the beginning of the <see cref="Clip"/> after a delay has passed.
        /// </summary>
        /// <param name="delaySamples">Optional delay in samples</param>
        public void Play(long delaySamples) {
            TimeSamples = 0;
            delay = delaySamples;
            IsPlaying = true;
        }

        /// <summary>
        /// Start playback from the beginning after the given time.
        /// </summary>
        /// <param name="seconds">Delay in seconds</param>
        public void PlayDelayed(float seconds) => Play((long)(seconds * Clip.SampleRate));

        /// <summary>
        /// Jump to a random position.
        /// </summary>
        public void RandomPosition() => TimeSamples = new Random().Next(0, Clip.Samples);

        /// <summary>
        /// Pause playback if it's not paused.
        /// </summary>
        public void Pause() => IsPlaying = false;

        /// <summary>
        /// Continue playback if it's paused.
        /// </summary>
        public void UnPause() => IsPlaying = true;

        /// <summary>
        /// Toggle between playback and pause.
        /// </summary>
        public void TogglePlay() => IsPlaying = !IsPlaying;

        /// <summary>
        /// Pause playback and reset position. The next <see cref="UnPause"/> will start playback from the beginning.
        /// </summary>
        public void Stop() {
            IsPlaying = false;
            TimeSamples = 0;
        }

        /// <summary>
        /// Copy the settings of another <see cref="Source"/>.
        /// </summary>
        /// <param name="from">Target source</param>
        public void CopySettings(Source from) {
            Clip = from.Clip;
            IsPlaying = from.IsPlaying;
            Loop = from.Loop;
            Mute = from.Mute;
            LFE = from.LFE;
            screenLocked = from.screenLocked;
            Volume = from.Volume;
            Pitch = from.Pitch;
            stereoPan = from.stereoPan;
            SpatialBlend = from.SpatialBlend;
            Size = from.Size;
            DopplerLevel = from.DopplerLevel;
            VolumeRolloff = from.VolumeRolloff;
            SpatialFilter = from.SpatialFilter;
            DistanceSimulation = from.DistanceSimulation;
            TimeSamples = from.TimeSamples;
        }

        /// <summary>
        /// Add a new <see cref="SpatialFilter"/> to this source.
        /// </summary>
        public void AddFilter(Filter target) {
            if (SpatialFilter == null) {
                SpatialFilter = target;
            } else {
                if (!(SpatialFilter is ComplexFilter)) {
                    Filter old = SpatialFilter;
                    SpatialFilter = new ComplexFilter();
                    ((ComplexFilter)SpatialFilter).Filters.Add(old);
                }
                ((ComplexFilter)SpatialFilter).Filters.Add(target);
            }
        }

        /// <summary>
        /// Remove a <see cref="SpatialFilter"/> from this source.
        /// </summary>
        public void RemoveFilter(Filter target) {
            if (SpatialFilter == target) {
                SpatialFilter = null;
            } else {
                ComplexFilter complex = (ComplexFilter)SpatialFilter;
                if (complex.Filters.Count == 1 && complex.Filters[0] == target) {
                    SpatialFilter = null;
                } else {
                    complex.Filters.Remove(target);
                }
            }
        }
    }
}